None = ε

tokenization brainstorm:
  indent = yes
  string = ' " \\
  comment = # // /*
  operator =
  identifier =
  number = int float complex

tokenization silva:
  _ = comment #
  indent = indent
  newline = newline () {} []
  string = string '' \\
  identifier = identifier
  number = number 0 0.0 0.0e0
  parens = parenthesis () {} []
  op = ~ , . : < > = + / & | ^ @ ! ? ; $ `

tokenization peat < default:
  string = string ''
  str = string '' r%""%
  variable = identifier snail_case endswith '_v'
  nt_base = identifier CamelCase
  function = identifier snail_case endswith'_f'
  kw = identifier concat ε
  op = operator | / ? =/ parenthesis ()

tokenization mine:
  indent = indent
  newline = newline () [] {}


language Seed uses tokenization Default:
  ⊙ = ( '-' Rule ) *
  Rule = Nonterminal ( '=' '[' x ']' | ExprOrAlias | '=/' Axe )
  ExprOrAlias = ( '=' | '=>' ) Expr
  Expr = axe Atom
    Parens    = nest  atom_nest '(' ')'
    Prefix    = rtl   prefix 'not'
    Postfix   = ltr   postfix '?' '*' '+'
    Concat    = ltr   infix_flat concat
    And       = ltr   infix_flat 'but_then'
    Or        = ltr   infix_flat '|'
  Atom = alias NonterminalMaybeVar | Terminal | Function
  NonterminalMaybeVar = Nonterminal ( '->' Variable ) ?
  Variable = identifier / '^[a-z].*_v$'

  Function =
    ⊙ = Name '(' Args ')'
    Name = identifier / '^[a-z].*_f$'
    Args = Arg ( ',' Arg ) *
    Arg = alias p.Expr | p.Variable

  Nonterminal =
    ⊙ = Base ( '.' Base ) *
    Base = '_' | 'x' | 'p' | identifier / '^[A-Z]'

  Terminal = string
             | 'identifier' ( '/' string ) ?
             | 'operator' ( '/' string ) ?
             | 'keywords_of' Nonterminal
             | 'string' | 'number'
             | 'any' | 'epsilon' | 'end_of_file'

# « [ 42 31 20 '--»--' ] »

